#!/usr/bin/env lua
local lfs = require 'lfs'

-- Patterns
local pid_pattern = "[0-9]+"
local proc_name_pattern = "Name:%s*(.+)"
local vm_rss_pattern = "VmRSS:%s*([0-9]+)"
local vm_swap_pattern = "VmSwap:%s*([0-9]+)"

local function get_process_values(path)
    local name, rss, swap
    for line in io.lines(path) do
        if name == nil then
            name = line:match(proc_name_pattern)
        elseif rss == nil then
            rss = line:match(vm_rss_pattern)
        elseif swap == nil then
            swap = line:match(vm_swap_pattern)
        else
            break
        end
    end
    return name, rss, swap
end

local function get_process_maps()
    local swap_map = {}
    local ram_map = {}
    for pid in lfs.dir("/proc/") do
        if pid:match(pid_pattern) then
            local f = table.concat({"/proc", pid}, "/")
            local attr = lfs.attributes(f)
            assert (type(attr) == "table")

            if attr.mode == "directory" then
                local name, rss, swap = get_process_values(table.concat({f, "status"}, "/"))
                if name and rss then
                    swap_map[#swap_map+1] = { tonumber(swap), name }
                    ram_map[#ram_map+1] = { tonumber(rss), name }
                end
            end
        end
    end
    table.sort(ram_map, function (a, b) return (a[1] > b[1]) end)
    table.sort(swap_map, function (a, b) return (a[1] > b[1]) end)
    return ram_map, swap_map
end


local function printTop(size)
    size = size or 10
    local ram_map, swap_map = get_process_maps()
    print(string.format("%-9s %35s %-9s %20s", "MEMORY", "Top " .. size .. " processes       ", "SWAP", ""))
    for i = 1, size do
        local ram_entry = ram_map[i]
        local swap_entry = swap_map[i]
        if ram_entry then
                print(string.format("%-9s %-35s %-9s %-20s", tonumber(string.format("%.0f", ram_entry[1] / 1024)) .. "M", ram_entry[2], tonumber(string.format("%.0f", swap_entry[1] / 1024)) .. "M", swap_entry[2]))
        end
    end
end

printTop(arg[1])
